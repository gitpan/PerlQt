
Here is my list of things to do in a random descending list of priority.

* Arbitrary argument-lists (...) between Perl signals and Perl slots.

* Check GIMMIE to see if we can avoid returning a value

* Fix 'sticky' list/combo-boxes (mainly in widget example)

* Finish upgrade to signals/slots

* Reuse *.config for Configure script

* Default arguments to signals/slots

* Attempt to allow various unsigned/int/long combinations in signals/slots

* Qt version-number checking

* undef $qApp causes a seg-fault??

* A config directory setup which will allow independant PerlQt modules to
be compiled without the main dist.
      * Any directory that wants to be treated specially (libperlqt) should
	include its own build instructions

* Write a QGlobal::import() that will only initialize enum values if
they are requested by a module.

* Namespace un-pollution by sticking everything into Qt:: and aliasing
everything back to Q*

* Find and fix the $_ contamination with signals/slots

* Garbage-collection of pQtSigSlots

* Write a pqtev (an xev clone) and stick it in contrib/

* Don't forget to try making want_destroy() test for a dead SvREFCNT()
to see if DESTROY() is being called manually.

* Make DELETE a permanent key, and compare directly with &sv_yes, &sv_no,
and &sv_undef

* Document and illustrate class interface.

* Document and illustrate PerlQt embedding.

* Fix bugs

* Get the typemap to read from className and convert to THAT type, not the
one requested

* Create a pembed

* Write a C++ Qt to PerlQt converter (in Perl)

* Add tests

* Allow connections to closure slots.

* Overloaded signals

* Make libperlqt more generic, so as to support other scripting languages?

* Overloaded slots

* Rewrite the whole thing in SWIG, to allow all the other scripting
languages in the world to bask in the glory of PerlQt.

